{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Jigar/Documents/GitHub/rooted/src/schemas/dailyWord.ts"],"sourcesContent":["/**\n * Zod schema for DailyWord database table\n * \n * This file defines the contract between:\n * - Database → API\n * - API → Client\n * \n * IMPORTANT: This schema MUST match the database table structure.\n * See: docs/context/01_architecture.md for SQL schema\n */\n\nimport { z } from 'zod';\n\n/**\n * Main schema for daily_words table\n */\nexport const DailyWordSchema = z.object({\n  // Primary key\n  id: z.number().int().positive(),\n\n  // Date when this word is scheduled to appear\n  // Format: YYYY-MM-DD (ISO 8601 date string)\n  publish_date: z.string().regex(\n    /^\\d{4}-\\d{2}-\\d{2}$/,\n    'Date must be in YYYY-MM-DD format'\n  ),\n\n  // The word itself (e.g., \"Sabotage\")\n  word: z.string().min(1, 'Word cannot be empty').max(100),\n\n  // Dictionary definition\n  definition: z.string().min(1, 'Definition cannot be empty'),\n\n  // Phonetic pronunciation (e.g., \"/ˈsæbətɑːʒ/\")\n  phonetic: z.string().max(100).nullable().optional(),\n\n  // Optional audio pronunciation URL (e.g., link to Forvo)\n  pronunciation_audio_url: z.string().url().nullable().optional(),\n\n  // Visualization type determines which visualizer component to use\n  visualization_type: z.enum(['MAP', 'TREE', 'TIMELINE', 'GRID'] as const),\n\n  // Main content (JSONB field in database)\n  // Structure varies based on visualization_type\n  // See: docs/context/04_schema_contracts.md for type-specific schemas\n  content_json: z.object({\n    // One-sentence teaser shown at top of page\n    hook: z.string().min(1, 'Hook cannot be empty'),\n\n    // \"Did you know?\" section content\n    fun_fact: z.string().min(1, 'Fun fact cannot be empty'),\n\n    // Optional deep dive content (unlocked with Nerd Mode)\n    nerd_mode: z.object({\n      ipa_full: z.string().optional(),\n      disputed_origin: z.string().optional(),\n      earliest_citation: z.string().optional(),\n    }).optional(),\n\n    // Type-specific visualization data\n    // Validated separately based on visualization_type\n    // We use z.any() here because the structure varies\n    visual_data: z.any(),\n  }),\n\n  // Theme color for this word (hex color code)\n  // Used for scroll indicators, map routes, tree links\n  accent_color: z.string().regex(\n    /^#[0-9A-Fa-f]{6}$/,\n    'Accent color must be a valid hex code (e.g., #FF5733)'\n  ).default('#000000'),\n\n  // Timestamp when word was created (ISO 8601 datetime)\n  created_at: z.string().nullable().optional(),\n\n  // Name of admin who approved this word\n  approved_by: z.string().max(50).nullable().optional(),\n\n  // Root family for Wordception feature\n  // e.g., \"PIE_kaput\" for words derived from Latin \"caput\"\n  // Used to find related words for ghost overlay\n  root_family: z.string().max(50).nullable().optional(),\n});\n\n/**\n * TypeScript type inferred from schema\n * \n * Usage:\n * ```typescript\n * const word: DailyWord = {\n *   id: 1,\n *   publish_date: '2025-02-07',\n *   word: 'Sabotage',\n *   // ... rest of fields\n * };\n * ```\n */\nexport type DailyWord = z.infer<typeof DailyWordSchema>;\n\n/**\n * Partial schema for updates (PATCH requests)\n * All fields except 'id' are optional\n */\nexport const DailyWordUpdateSchema = DailyWordSchema\n  .partial()\n  .omit({ id: true })\n  .strict();\n\n/**\n * Schema for creating new words (POST requests)\n * Omits auto-generated fields (id, created_at)\n */\nexport const DailyWordCreateSchema = DailyWordSchema\n  .omit({\n    id: true,\n    created_at: true\n  })\n  .strict();\n\n/**\n * Lightweight schema for word list responses\n * Only includes essential fields for listing\n */\nexport const DailyWordListItemSchema = DailyWordSchema.pick({\n  id: true,\n  publish_date: true,\n  word: true,\n  visualization_type: true,\n});\n\nexport type DailyWordListItem = z.infer<typeof DailyWordListItemSchema>;\n\n/**\n * Helper function to validate database query results\n * \n * Usage:\n * ```typescript\n * const result = await sql`SELECT * FROM daily_words WHERE id = ${id}`;\n * const word = validateDailyWord(result.rows[0]);\n * ```\n * \n * @param data - Raw data from database\n * @returns Validated DailyWord object\n * @throws {z.ZodError} If validation fails\n */\nexport function validateDailyWord(data: unknown): DailyWord {\n  return DailyWordSchema.parse(data);\n}\n\n/**\n * Safe validation that returns result instead of throwing\n * \n * Usage:\n * ```typescript\n * const result = validateDailyWordSafe(data);\n * if (result.success) {\n *   console.log(result.data.word);\n * } else {\n *   console.error(result.error);\n * }\n * ```\n */\nexport function validateDailyWordSafe(data: unknown) {\n  return DailyWordSchema.safeParse(data);\n}\n\n/**\n * Validation for date strings\n * Ensures date is in correct format and is a valid date\n */\nexport const DateStringSchema = z.string()\n  .regex(/^\\d{4}-\\d{2}-\\d{2}$/, 'Date must be in YYYY-MM-DD format')\n  .refine(\n    (date) => {\n      const parsed = Date.parse(date);\n      return !isNaN(parsed);\n    },\n    { message: 'Date must be a valid date' }\n  );\n\n/**\n * Validation for word slugs (URL-safe word identifiers)\n * e.g., \"sabotage\", \"mother\", \"algorithm\"\n */\nexport const WordSlugSchema = z.string()\n  .min(1)\n  .max(100)\n  .regex(\n    /^[a-z0-9-]+$/,\n    'Slug must contain only lowercase letters, numbers, and hyphens'\n  );\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;CASC,GAED;;AAKO,MAAM,kBAAkB,oLAAC,CAAC,MAAM,CAAC;IACtC,cAAc;IACd,IAAI,oLAAC,CAAC,MAAM,GAAG,GAAG,GAAG,QAAQ;IAE7B,6CAA6C;IAC7C,4CAA4C;IAC5C,cAAc,oLAAC,CAAC,MAAM,GAAG,KAAK,CAC5B,uBACA;IAGF,qCAAqC;IACrC,MAAM,oLAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG,wBAAwB,GAAG,CAAC;IAEpD,wBAAwB;IACxB,YAAY,oLAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG;IAE9B,+CAA+C;IAC/C,UAAU,oLAAC,CAAC,MAAM,GAAG,GAAG,CAAC,KAAK,QAAQ,GAAG,QAAQ;IAEjD,yDAAyD;IACzD,yBAAyB,oLAAC,CAAC,MAAM,GAAG,GAAG,GAAG,QAAQ,GAAG,QAAQ;IAE7D,kEAAkE;IAClE,oBAAoB,oLAAC,CAAC,IAAI,CAAC;QAAC;QAAO;QAAQ;QAAY;KAAO;IAE9D,yCAAyC;IACzC,+CAA+C;IAC/C,qEAAqE;IACrE,cAAc,oLAAC,CAAC,MAAM,CAAC;QACrB,2CAA2C;QAC3C,MAAM,oLAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG;QAExB,kCAAkC;QAClC,UAAU,oLAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG;QAE5B,uDAAuD;QACvD,WAAW,oLAAC,CAAC,MAAM,CAAC;YAClB,UAAU,oLAAC,CAAC,MAAM,GAAG,QAAQ;YAC7B,iBAAiB,oLAAC,CAAC,MAAM,GAAG,QAAQ;YACpC,mBAAmB,oLAAC,CAAC,MAAM,GAAG,QAAQ;QACxC,GAAG,QAAQ;QAEX,mCAAmC;QACnC,mDAAmD;QACnD,mDAAmD;QACnD,aAAa,oLAAC,CAAC,GAAG;IACpB;IAEA,6CAA6C;IAC7C,qDAAqD;IACrD,cAAc,oLAAC,CAAC,MAAM,GAAG,KAAK,CAC5B,qBACA,yDACA,OAAO,CAAC;IAEV,sDAAsD;IACtD,YAAY,oLAAC,CAAC,MAAM,GAAG,QAAQ,GAAG,QAAQ;IAE1C,uCAAuC;IACvC,aAAa,oLAAC,CAAC,MAAM,GAAG,GAAG,CAAC,IAAI,QAAQ,GAAG,QAAQ;IAEnD,sCAAsC;IACtC,yDAAyD;IACzD,+CAA+C;IAC/C,aAAa,oLAAC,CAAC,MAAM,GAAG,GAAG,CAAC,IAAI,QAAQ,GAAG,QAAQ;AACrD;AAqBO,MAAM,wBAAwB,gBAClC,OAAO,GACP,IAAI,CAAC;IAAE,IAAI;AAAK,GAChB,MAAM;AAMF,MAAM,wBAAwB,gBAClC,IAAI,CAAC;IACJ,IAAI;IACJ,YAAY;AACd,GACC,MAAM;AAMF,MAAM,0BAA0B,gBAAgB,IAAI,CAAC;IAC1D,IAAI;IACJ,cAAc;IACd,MAAM;IACN,oBAAoB;AACtB;AAiBO,SAAS,kBAAkB,IAAa;IAC7C,OAAO,gBAAgB,KAAK,CAAC;AAC/B;AAeO,SAAS,sBAAsB,IAAa;IACjD,OAAO,gBAAgB,SAAS,CAAC;AACnC;AAMO,MAAM,mBAAmB,oLAAC,CAAC,MAAM,GACrC,KAAK,CAAC,uBAAuB,qCAC7B,MAAM,CACL,CAAC;IACC,MAAM,SAAS,KAAK,KAAK,CAAC;IAC1B,OAAO,CAAC,MAAM;AAChB,GACA;IAAE,SAAS;AAA4B;AAOpC,MAAM,iBAAiB,oLAAC,CAAC,MAAM,GACnC,GAAG,CAAC,GACJ,GAAG,CAAC,KACJ,KAAK,CACJ,gBACA"}},
    {"offset": {"line": 157, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Jigar/Documents/GitHub/rooted/src/lib/db.ts"],"sourcesContent":["/**\r\n * Database Helper\r\n * \r\n * Provides typed wrappers around @neondatabase/serverless for safe database operations.\r\n * All queries use parameterized statements to prevent SQL injection.\r\n * \r\n * Migration note: This uses @neondatabase/serverless as the recommended replacement\r\n * for the deprecated @vercel/postgres package.\r\n */\r\n\r\nimport { neon } from '@neondatabase/serverless';\r\nimport { DailyWord, DailyWordSchema } from '@/src/schemas/dailyWord';\r\n\r\n// Initialize Neon client with connection string from environment\r\nconst sql = neon(process.env.DATABASE_URL!);\r\n\r\n/**\r\n * Get word by publish date\r\n * \r\n * @param date - Date string in YYYY-MM-DD format\r\n * @returns DailyWord or null if not found\r\n * @throws ZodError if database data fails validation\r\n */\r\nexport async function getWordByDate(date: string): Promise<DailyWord | null> {\r\n  const result = await sql`\r\n    SELECT \r\n      id,\r\n      publish_date::text,\r\n      word,\r\n      definition,\r\n      phonetic,\r\n      pronunciation_audio_url,\r\n      visualization_type,\r\n      content_json,\r\n      accent_color,\r\n      created_at::text,\r\n      approved_by,\r\n      root_family\r\n    FROM daily_words\r\n    WHERE publish_date = ${date}\r\n    LIMIT 1\r\n  `;\r\n\r\n  if (result.length === 0) {\r\n    return null;\r\n  }\r\n\r\n  // Validate database output with Zod (throws on failure)\r\n  return DailyWordSchema.parse(result[0]);\r\n}\r\n\r\n/**\r\n * Get word by slug (word name, lowercase)\r\n * \r\n * @param slug - Word slug (e.g., \"sabotage\")\r\n * @returns DailyWord or null if not found\r\n * @throws ZodError if database data fails validation\r\n */\r\nexport async function getWordBySlug(slug: string): Promise<DailyWord | null> {\r\n  const result = await sql`\r\n    SELECT \r\n      id,\r\n      publish_date::text,\r\n      word,\r\n      definition,\r\n      phonetic,\r\n      pronunciation_audio_url,\r\n      visualization_type,\r\n      content_json,\r\n      accent_color,\r\n      created_at::text,\r\n      approved_by,\r\n      root_family\r\n    FROM daily_words\r\n    WHERE LOWER(word) = LOWER(${slug})\r\n    ORDER BY publish_date DESC\r\n    LIMIT 1\r\n  `;\r\n\r\n  if (result.length === 0) {\r\n    return null;\r\n  }\r\n\r\n  return DailyWordSchema.parse(result[0]);\r\n}\r\n\r\n/**\r\n * Get today's date in YYYY-MM-DD format\r\n * Uses server timezone (consistent across requests)\r\n */\r\nexport function getTodayDateString(): string {\r\n  return new Date().toISOString().split('T')[0];\r\n}\r\n"],"names":[],"mappings":";;;;;;;;AAAA;;;;;;;;CAQC,GAED;AACA;;;AAEA,iEAAiE;AACjE,MAAM,MAAM,IAAA,gKAAI,EAAC,QAAQ,GAAG,CAAC,YAAY;AASlC,eAAe,cAAc,IAAY;IAC9C,MAAM,SAAS,MAAM,GAAG,CAAC;;;;;;;;;;;;;;;yBAeF,EAAE,KAAK;;EAE9B,CAAC;IAED,IAAI,OAAO,MAAM,KAAK,GAAG;QACvB,OAAO;IACT;IAEA,wDAAwD;IACxD,OAAO,gJAAe,CAAC,KAAK,CAAC,MAAM,CAAC,EAAE;AACxC;AASO,eAAe,cAAc,IAAY;IAC9C,MAAM,SAAS,MAAM,GAAG,CAAC;;;;;;;;;;;;;;;8BAeG,EAAE,KAAK;;;EAGnC,CAAC;IAED,IAAI,OAAO,MAAM,KAAK,GAAG;QACvB,OAAO;IACT;IAEA,OAAO,gJAAe,CAAC,KAAK,CAAC,MAAM,CAAC,EAAE;AACxC;AAMO,SAAS;IACd,OAAO,IAAI,OAAO,WAAW,GAAG,KAAK,CAAC,IAAI,CAAC,EAAE;AAC/C"}},
    {"offset": {"line": 236, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Jigar/Documents/GitHub/rooted/src/schemas/apiResponses.ts"],"sourcesContent":["/**\r\n * API Response Schemas\r\n * \r\n * Defines standardized response formats for all API endpoints.\r\n * See: docs/context/04_schema_contracts.md\r\n */\r\n\r\nimport { z } from 'zod';\r\n\r\n/**\r\n * Standard error response schema\r\n * Used for all 4xx and 5xx responses\r\n */\r\nexport const ErrorResponseSchema = z.object({\r\n    error: z.string().min(1, 'Error message is required'),\r\n    code: z.string().optional(),\r\n    details: z.any().optional(),\r\n});\r\n\r\nexport type ErrorResponse = z.infer<typeof ErrorResponseSchema>;\r\n\r\n/**\r\n * Common error responses (pre-defined for consistency)\r\n */\r\nexport const CommonErrors = {\r\n    NOT_FOUND: { error: 'Resource not found' } satisfies ErrorResponse,\r\n    METHOD_NOT_ALLOWED: { error: 'Method not allowed' } satisfies ErrorResponse,\r\n    INTERNAL_ERROR: { error: 'Internal server error' } satisfies ErrorResponse,\r\n    VALIDATION_ERROR: { error: 'Data integrity error' } satisfies ErrorResponse,\r\n    UNAUTHORIZED: { error: 'Unauthorized' } satisfies ErrorResponse,\r\n} as const;\r\n\r\n/**\r\n * 404 specific errors\r\n */\r\nexport const NotFoundErrors = {\r\n    WORD_NOT_FOUND: { error: 'No word scheduled for today', code: 'WORD_NOT_FOUND' } satisfies ErrorResponse,\r\n    SLUG_NOT_FOUND: { error: 'Word not found', code: 'SLUG_NOT_FOUND' } satisfies ErrorResponse,\r\n} as const;\r\n"],"names":[],"mappings":";;;;;;;;AAAA;;;;;CAKC,GAED;;AAMO,MAAM,sBAAsB,oLAAC,CAAC,MAAM,CAAC;IACxC,OAAO,oLAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG;IACzB,MAAM,oLAAC,CAAC,MAAM,GAAG,QAAQ;IACzB,SAAS,oLAAC,CAAC,GAAG,GAAG,QAAQ;AAC7B;AAOO,MAAM,eAAe;IACxB,WAAW;QAAE,OAAO;IAAqB;IACzC,oBAAoB;QAAE,OAAO;IAAqB;IAClD,gBAAgB;QAAE,OAAO;IAAwB;IACjD,kBAAkB;QAAE,OAAO;IAAuB;IAClD,cAAc;QAAE,OAAO;IAAe;AAC1C;AAKO,MAAM,iBAAiB;IAC1B,gBAAgB;QAAE,OAAO;QAA+B,MAAM;IAAiB;IAC/E,gBAAgB;QAAE,OAAO;QAAkB,MAAM;IAAiB;AACtE"}},
    {"offset": {"line": 287, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Jigar/Documents/GitHub/rooted/app/api/word/today/route.ts"],"sourcesContent":["/**\r\n * GET /api/word/today\r\n * \r\n * Returns the word scheduled for the current date.\r\n * \r\n * Responses:\r\n * - 200: DailyWord object\r\n * - 404: No word scheduled for today\r\n * - 500: Data integrity error (schema validation failed)\r\n * \r\n * Security:\r\n * - Uses parameterized SQL queries\r\n * - Validates database output with Zod\r\n */\r\n\r\nimport { NextResponse } from 'next/server';\r\nimport { z } from 'zod';\r\nimport { getWordByDate, getTodayDateString } from '@/src/lib/db';\r\nimport { NotFoundErrors, CommonErrors } from '@/src/schemas/apiResponses';\r\n\r\nexport async function GET(): Promise<NextResponse> {\r\n    try {\r\n        // Get current date in YYYY-MM-DD format\r\n        const today = getTodayDateString();\r\n\r\n        // Query database for today's word\r\n        const word = await getWordByDate(today);\r\n\r\n        // Check if word exists for today\r\n        if (!word) {\r\n            return NextResponse.json(\r\n                NotFoundErrors.WORD_NOT_FOUND,\r\n                { status: 404 }\r\n            );\r\n        }\r\n\r\n        // Return validated word data\r\n        return NextResponse.json(word);\r\n\r\n    } catch (error) {\r\n        // Handle Zod validation errors (database returned invalid data)\r\n        if (error instanceof z.ZodError) {\r\n            console.error('Schema validation failed:', error.issues);\r\n            return NextResponse.json(\r\n                CommonErrors.VALIDATION_ERROR,\r\n                { status: 500 }\r\n            );\r\n        }\r\n\r\n        // Handle unexpected errors\r\n        console.error('Unexpected error in /api/word/today:', error);\r\n        return NextResponse.json(\r\n            CommonErrors.INTERNAL_ERROR,\r\n            { status: 500 }\r\n        );\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;;;;;;;;;;;;;CAaC,GAED;AACA;AACA;AACA;;;;;AAEO,eAAe;IAClB,IAAI;QACA,wCAAwC;QACxC,MAAM,QAAQ,IAAA,wIAAkB;QAEhC,kCAAkC;QAClC,MAAM,OAAO,MAAM,IAAA,mIAAa,EAAC;QAEjC,iCAAiC;QACjC,IAAI,CAAC,MAAM;YACP,OAAO,gJAAY,CAAC,IAAI,CACpB,kJAAc,CAAC,cAAc,EAC7B;gBAAE,QAAQ;YAAI;QAEtB;QAEA,6BAA6B;QAC7B,OAAO,gJAAY,CAAC,IAAI,CAAC;IAE7B,EAAE,OAAO,OAAO;QACZ,gEAAgE;QAChE,IAAI,iBAAiB,oLAAC,CAAC,QAAQ,EAAE;YAC7B,QAAQ,KAAK,CAAC,6BAA6B,MAAM,MAAM;YACvD,OAAO,gJAAY,CAAC,IAAI,CACpB,gJAAY,CAAC,gBAAgB,EAC7B;gBAAE,QAAQ;YAAI;QAEtB;QAEA,2BAA2B;QAC3B,QAAQ,KAAK,CAAC,wCAAwC;QACtD,OAAO,gJAAY,CAAC,IAAI,CACpB,gJAAY,CAAC,cAAc,EAC3B;YAAE,QAAQ;QAAI;IAEtB;AACJ"}}]
}